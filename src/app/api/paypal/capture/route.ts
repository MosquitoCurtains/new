/**
 * PayPal Capture API
 * 
 * Captures a PayPal order after customer approval.
 * This is the return URL after PayPal checkout.
 * 
 * Flow:
 * 1. Capture payment via PayPal
 * 2. Load cart from DB (saved during create-order)
 * 3. Create order with correct column names + copy line items
 * 4. Update cart status to 'converted'
 * 5. Track attribution, send emails
 */

import { NextRequest, NextResponse } from 'next/server'
import { capturePayPalOrder } from '@/lib/paypal'
import { createAdminClient } from '@/lib/supabase/admin'
import { sendOrderConfirmation, sendNewOrderAlert } from '@/lib/email/notifications'

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const token = searchParams.get('token') // PayPal adds this
    const cartId = searchParams.get('cartId')
    
    // Get tracking cookies
    const visitorId = request.cookies.get('mc_visitor_id')?.value
    const sessionId = request.cookies.get('mc_session_id')?.value

    if (!token) {
      return NextResponse.redirect(new URL('/cart?error=missing_token', request.url))
    }

    // Capture the payment
    const captureResult = await capturePayPalOrder(token)

    if (captureResult.status !== 'COMPLETED') {
      console.error('Payment not completed:', captureResult.status)
      return NextResponse.redirect(new URL(`/cart?error=payment_${captureResult.status.toLowerCase()}`, request.url))
    }

    const adminSupabase = createAdminClient()
    
    // =========================================================================
    // Load cart from database
    // =========================================================================
    let cart: Record<string, unknown> | null = null
    let cartItems: Array<Record<string, unknown>> | null = null

    if (cartId) {
      const { data: cartData } = await adminSupabase
        .from('carts')
        .select('*')
        .eq('id', cartId)
        .single()
      
      cart = cartData

      const { data: items } = await adminSupabase
        .from('line_items')
        .select('*, line_item_options(*)')
        .eq('cart_id', cartId)
      
      cartItems = items
    }

    // =========================================================================
    // Get visitor and customer data
    // =========================================================================
    let actualVisitorId: string | null = null
    let actualSessionId: string | null = null
    let customerId: string | null = null
    
    if (visitorId) {
      const { data: visitor } = await adminSupabase
        .from('visitors')
        .select('id, customer_id')
        .eq('fingerprint', visitorId)
        .single()
      
      if (visitor) {
        actualVisitorId = visitor.id
        customerId = visitor.customer_id
      }
    }
    
    if (sessionId) {
      const { data: session } = await adminSupabase
        .from('sessions')
        .select('id')
        .eq('id', sessionId)
        .single()
      
      if (session) {
        actualSessionId = session.id
      }
    }
    
    // If no customer yet, try to find by email
    if (!customerId && captureResult.payer.email_address) {
      const { data: existingCustomer } = await adminSupabase
        .from('customers')
        .select('id')
        .eq('email', captureResult.payer.email_address.toLowerCase())
        .single()
      
      customerId = existingCustomer?.id || null
    }

    // =========================================================================
    // Create order in database with CORRECT column names
    // order_number is auto-generated by the DB trigger
    // =========================================================================
    const capturedAmount = parseFloat(captureResult.amount)

    const { data: order, error: orderError } = await adminSupabase
      .from('orders')
      .insert({
        // Customer info
        email: captureResult.payer.email_address || cart?.email as string || '',
        billing_first_name: captureResult.payer.name?.given_name || null,
        billing_last_name: captureResult.payer.name?.surname || null,
        customer_id: customerId,

        // Shipping (from cart if available)
        shipping_first_name: (cart?.shipping_first_name as string) || captureResult.payer.name?.given_name || null,
        shipping_last_name: (cart?.shipping_last_name as string) || captureResult.payer.name?.surname || null,
        shipping_address_1: (cart?.shipping_address_1 as string) || null,
        shipping_city: (cart?.shipping_city as string) || null,
        shipping_state: (cart?.shipping_state as string) || null,
        shipping_zip: (cart?.shipping_zip as string) || null,
        shipping_country: (cart?.shipping_country as string) || 'US',

        // Financials
        subtotal: cart ? Number(cart.subtotal) || capturedAmount : capturedAmount,
        tax_amount: cart ? Number(cart.tax_amount) || 0 : 0,
        shipping_amount: cart ? Number(cart.shipping_amount) || 0 : 0,
        total: capturedAmount,

        // Payment
        payment_method: 'paypal',
        payment_transaction_id: captureResult.captureId,
        payment_status: 'paid',
        paid_at: new Date().toISOString(),

        // Status
        status: 'processing',

        // References
        cart_id: cartId || null,
        order_source: 'online_self',

        // Journey tracking
        visitor_id: actualVisitorId,
        session_id: actualSessionId,
      })
      .select('*')
      .single()

    if (orderError) {
      console.error('Error creating order:', orderError)
      // Payment was captured â€” redirect with PayPal token so customer isn't lost
      return NextResponse.redirect(new URL(`/order/${token}?success=true&error=order_save_failed`, request.url))
    }

    // =========================================================================
    // Copy line items from cart to order
    // =========================================================================
    if (cartItems && cartItems.length > 0) {
      for (const item of cartItems) {
        const { data: newItem } = await adminSupabase
          .from('line_items')
          .insert({
            order_id: order.id,
            product_id: item.product_id || null,
            product_sku: item.product_sku,
            product_name: item.product_name,
            quantity: item.quantity || 1,
            width_inches: item.width_inches || null,
            height_inches: item.height_inches || null,
            length_feet: item.length_feet || null,
            unit_price: item.unit_price,
            line_total: item.line_total,
            adjustment_type: item.adjustment_type || null,
            adjustment_reason: item.adjustment_reason || null,
            panel_specs: item.panel_specs || {},
            original_bundle_name: item.original_bundle_name || null,
          })
          .select('id')
          .single()

        // Copy options
        const itemOptions = item.line_item_options as Array<Record<string, unknown>> | null
        if (newItem && itemOptions && itemOptions.length > 0) {
          const options = itemOptions.map((opt) => ({
            line_item_id: newItem.id,
            option_name: opt.option_name as string,
            option_value: opt.option_value as string,
            option_display: (opt.option_display as string) || null,
            price_impact: (opt.price_impact as number) || 0,
          }))
          await adminSupabase.from('line_item_options').insert(options)
        }
      }
    }

    // =========================================================================
    // Update cart status to converted
    // =========================================================================
    if (cartId) {
      await adminSupabase
        .from('carts')
        .update({ status: 'converted' })
        .eq('id', cartId)
    }

    // =========================================================================
    // Track purchase_completed event
    // =========================================================================
    if (actualVisitorId) {
      await adminSupabase.from('journey_events').insert({
        visitor_id: actualVisitorId,
        session_id: actualSessionId,
        customer_id: customerId,
        event_type: 'purchase_completed',
        event_data: {
          order_id: order.id,
          order_number: order.order_number,
          order_total: captureResult.amount,
          payment_method: 'paypal',
        }
      })
      
      // Update session as converted
      if (actualSessionId) {
        await adminSupabase
          .from('sessions')
          .update({
            converted: true,
            conversion_type: 'purchase',
            conversion_at: new Date().toISOString()
          })
          .eq('id', actualSessionId)
      }
      
      // Update customer status and first_purchase_at
      if (customerId) {
        await adminSupabase
          .from('customers')
          .update({
            customer_status: 'customer',
            first_purchase_at: new Date().toISOString()
          })
          .eq('id', customerId)
          .is('first_purchase_at', null) // Only if not already set
      }
    }

    // =========================================================================
    // Send email notifications (fire-and-forget)
    // =========================================================================
    const emailData = {
      orderNumber: order.order_number,
      orderId: order.id,
      customerFirstName: order.billing_first_name || '',
      customerLastName: order.billing_last_name || '',
      customerEmail: order.email || '',
      totalAmount: order.total,
      createdAt: order.created_at,
    }
    sendOrderConfirmation(emailData).catch(console.error)
    sendNewOrderAlert(emailData).catch(console.error)

    // Redirect to order confirmation using the DB order ID
    return NextResponse.redirect(new URL(`/order/${order.id}?success=true`, request.url))
    
  } catch (error) {
    console.error('PayPal capture error:', error)
    return NextResponse.redirect(new URL('/cart?error=capture_failed', request.url))
  }
}

// Also handle POST for programmatic captures
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const { orderId, cartId, visitorId, sessionId } = body

    if (!orderId) {
      return NextResponse.json(
        { error: 'Order ID required' },
        { status: 400 }
      )
    }

    const captureResult = await capturePayPalOrder(orderId)

    if (captureResult.status !== 'COMPLETED') {
      return NextResponse.json(
        { error: `Payment ${captureResult.status}` },
        { status: 400 }
      )
    }

    const adminSupabase = createAdminClient()
    
    // Load cart if cartId provided
    let cart: Record<string, unknown> | null = null
    if (cartId) {
      const { data } = await adminSupabase
        .from('carts')
        .select('*')
        .eq('id', cartId)
        .single()
      cart = data
    }

    // Get visitor data
    let actualVisitorId: string | null = null
    let actualSessionId: string | null = null
    let customerId: string | null = null
    
    if (visitorId) {
      const { data: visitor } = await adminSupabase
        .from('visitors')
        .select('id, customer_id')
        .eq('fingerprint', visitorId)
        .single()
      
      if (visitor) {
        actualVisitorId = visitor.id
        customerId = visitor.customer_id
      }
    }
    
    if (sessionId) {
      const { data: session } = await adminSupabase
        .from('sessions')
        .select('id')
        .eq('id', sessionId)
        .single()
      
      if (session) {
        actualSessionId = session.id
      }
    }

    const capturedAmount = parseFloat(captureResult.amount)

    // Create order with correct column names
    const { data: order, error: orderError } = await adminSupabase
      .from('orders')
      .insert({
        email: captureResult.payer.email_address || cart?.email as string || '',
        billing_first_name: captureResult.payer.name?.given_name || null,
        billing_last_name: captureResult.payer.name?.surname || null,
        customer_id: customerId,
        subtotal: cart ? Number(cart.subtotal) || capturedAmount : capturedAmount,
        tax_amount: cart ? Number(cart.tax_amount) || 0 : 0,
        shipping_amount: cart ? Number(cart.shipping_amount) || 0 : 0,
        total: capturedAmount,
        payment_method: 'paypal',
        payment_transaction_id: captureResult.captureId,
        payment_status: 'paid',
        paid_at: new Date().toISOString(),
        status: 'processing',
        cart_id: cartId || null,
        order_source: 'online_self',
        visitor_id: actualVisitorId,
        session_id: actualSessionId,
      })
      .select('*')
      .single()

    if (orderError) {
      console.error('Error creating order:', orderError)
      return NextResponse.json(
        { error: 'Payment captured but order creation failed', captureId: captureResult.captureId },
        { status: 500 }
      )
    }

    // Copy line items from cart if available
    if (cartId) {
      const { data: cartItems } = await adminSupabase
        .from('line_items')
        .select('*, line_item_options(*)')
        .eq('cart_id', cartId)

      if (cartItems && cartItems.length > 0) {
        for (const item of cartItems) {
          const { data: newItem } = await adminSupabase
            .from('line_items')
            .insert({
              order_id: order.id,
              product_id: item.product_id || null,
              product_sku: item.product_sku,
              product_name: item.product_name,
              quantity: item.quantity || 1,
              width_inches: item.width_inches || null,
              height_inches: item.height_inches || null,
              length_feet: item.length_feet || null,
              unit_price: item.unit_price,
              line_total: item.line_total,
              panel_specs: item.panel_specs || {},
            })
            .select('id')
            .single()

          if (newItem && item.line_item_options?.length > 0) {
            const options = item.line_item_options.map((opt: Record<string, unknown>) => ({
              line_item_id: newItem.id,
              option_name: opt.option_name as string,
              option_value: opt.option_value as string,
              option_display: (opt.option_display as string) || null,
              price_impact: (opt.price_impact as number) || 0,
            }))
            await adminSupabase.from('line_item_options').insert(options)
          }
        }
      }

      // Update cart status
      await adminSupabase
        .from('carts')
        .update({ status: 'converted' })
        .eq('id', cartId)
    }
    
    // Track purchase event
    if (actualVisitorId) {
      await adminSupabase.from('journey_events').insert({
        visitor_id: actualVisitorId,
        session_id: actualSessionId,
        customer_id: customerId,
        event_type: 'purchase_completed',
        event_data: {
          order_id: order.id,
          order_number: order.order_number,
          order_total: captureResult.amount,
          payment_method: 'paypal',
        }
      })
    }

    // Send email notifications (fire-and-forget)
    const emailData = {
      orderNumber: order.order_number,
      orderId: order.id,
      customerFirstName: order.billing_first_name || '',
      customerLastName: order.billing_last_name || '',
      customerEmail: order.email || '',
      totalAmount: order.total,
      createdAt: order.created_at,
    }
    sendOrderConfirmation(emailData).catch(console.error)
    sendNewOrderAlert(emailData).catch(console.error)

    return NextResponse.json({
      success: true,
      orderId: order.id,
      orderNumber: order.order_number,
      captureId: captureResult.captureId,
      amount: captureResult.amount,
    })
    
  } catch (error) {
    console.error('PayPal capture error:', error)
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to capture payment' },
      { status: 500 }
    )
  }
}
