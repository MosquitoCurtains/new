import { NextRequest, NextResponse } from 'next/server'
import { createAdminClient } from '@/lib/supabase/admin'

/**
 * POST /api/admin/orders
 * Create an order from a cart. Copies line items, updates statuses.
 */
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const {
      cart_id,
      salesperson_id: reqSalespersonId,
      payment_method,
      payment_transaction_id,
      payment_status: requestedPaymentStatus,
      billing_first_name,
      billing_last_name,
      billing_phone,
      billing_email,
      billing_address_1,
      billing_address_2,
      billing_city,
      billing_state,
      billing_zip,
      billing_country,
      shipping_first_name: reqShipFirst,
      shipping_last_name: reqShipLast,
      shipping_address_1: reqShipAddr1,
      shipping_address_2: reqShipAddr2,
      shipping_city: reqShipCity,
      shipping_state: reqShipState,
      shipping_zip: reqShipZip,
      internal_note,
      order_source: reqOrderSource,
    } = body

    if (!cart_id) {
      return NextResponse.json(
        { error: 'cart_id is required' },
        { status: 400 }
      )
    }

    const supabase = createAdminClient()

    // Fetch cart with project info
    const { data: cart, error: cartError } = await supabase
      .from('carts')
      .select(`
        *,
        projects!project_id (
          id, email, first_name, last_name, phone, lead_id, customer_id
        )
      `)
      .eq('id', cart_id)
      .single()

    if (cartError || !cart) {
      return NextResponse.json(
        { error: 'Cart not found' },
        { status: 404 }
      )
    }

    const project = (cart as Record<string, unknown>).projects as Record<string, unknown> | null

    // Determine payment status and initial order status
    const finalPaymentStatus = requestedPaymentStatus || 'pending'
    const initialOrderStatus = finalPaymentStatus === 'paid' ? 'processing' : 'pending'

    // Create the order (order_number is auto-generated by the DB trigger)
    const { data: order, error: orderError } = await supabase
      .from('orders')
      .insert({
        customer_id: project?.customer_id as string || cart.customer_id || null,
        email: billing_email || project?.email as string || cart.email || '',
        billing_first_name: billing_first_name || project?.first_name as string || null,
        billing_last_name: billing_last_name || project?.last_name as string || null,
        billing_phone: billing_phone || project?.phone as string || null,
        billing_address_1: billing_address_1 || null,
        billing_address_2: billing_address_2 || null,
        billing_city: billing_city || null,
        billing_state: billing_state || null,
        billing_zip: billing_zip || null,
        billing_country: billing_country || 'US',
        shipping_first_name: reqShipFirst || cart.shipping_first_name || billing_first_name || project?.first_name as string || null,
        shipping_last_name: reqShipLast || cart.shipping_last_name || billing_last_name || project?.last_name as string || null,
        shipping_address_1: reqShipAddr1 || cart.shipping_address_1 || billing_address_1 || null,
        shipping_address_2: reqShipAddr2 || cart.shipping_address_2 || billing_address_2 || null,
        shipping_city: reqShipCity || cart.shipping_city || billing_city || null,
        shipping_state: reqShipState || cart.shipping_state || billing_state || null,
        shipping_zip: reqShipZip || cart.shipping_zip || billing_zip || null,
        shipping_country: cart.shipping_country || billing_country || 'US',
        status: initialOrderStatus,
        subtotal: cart.subtotal || 0,
        tax_amount: cart.tax_amount || 0,
        shipping_amount: cart.shipping_amount || 0,
        total: cart.total || 0,
        payment_method: payment_method || null,
        payment_transaction_id: payment_transaction_id || null,
        payment_status: finalPaymentStatus,
        paid_at: finalPaymentStatus === 'paid' ? new Date().toISOString() : null,
        salesperson_id: reqSalespersonId || cart.salesperson_id || null,
        project_id: cart.project_id || null,
        cart_id: cart.id,
        source: 'admin',
        order_source: reqOrderSource || 'admin_sales',
        internal_note: internal_note || null,
      })
      .select('*')
      .single()

    if (orderError || !order) {
      console.error('Error creating order:', orderError)
      return NextResponse.json(
        { error: 'Failed to create order' },
        { status: 500 }
      )
    }

    // Copy line items from cart to order
    const { data: cartItems } = await supabase
      .from('line_items')
      .select('*, line_item_options(*)')
      .eq('cart_id', cart_id)

    if (cartItems && cartItems.length > 0) {
      for (const item of cartItems) {
        const { data: newItem } = await supabase
          .from('line_items')
          .insert({
            order_id: order.id,
            cart_id: cart_id, // Keep reference to original cart
            product_id: item.product_id,
            product_sku: item.product_sku,
            product_name: item.product_name,
            quantity: item.quantity,
            width_inches: item.width_inches,
            height_inches: item.height_inches,
            length_feet: item.length_feet,
            unit_price: item.unit_price,
            line_total: item.line_total,
            adjustment_type: item.adjustment_type,
            adjustment_reason: item.adjustment_reason,
            panel_specs: item.panel_specs,
            original_bundle_name: item.original_bundle_name,
          })
          .select('id')
          .single()

        // Copy options
        if (newItem && item.line_item_options && item.line_item_options.length > 0) {
          const options = item.line_item_options.map((opt: Record<string, unknown>) => ({
            line_item_id: newItem.id,
            option_name: opt.option_name,
            option_value: opt.option_value,
            option_display: opt.option_display || null,
            price_impact: opt.price_impact || 0,
          }))
          await supabase.from('line_item_options').insert(options)
        }
      }
    }

    // Update cart status to converted
    await supabase
      .from('carts')
      .update({ status: 'converted' })
      .eq('id', cart_id)

    // Update project status to order_placed
    if (cart.project_id) {
      await supabase
        .from('projects')
        .update({ status: 'order_placed' })
        .eq('id', cart.project_id)
    }

    // =====================================================================
    // Lead → Customer conversion
    // If the project has a lead, upsert a customer record and mark lead converted
    // =====================================================================
    if (project?.lead_id) {
      try {
        // Fetch lead data
        const { data: lead } = await supabase
          .from('leads')
          .select('id, email, first_name, last_name, phone')
          .eq('id', project.lead_id as string)
          .single()

        if (lead) {
          const orderEmail = order.email || lead.email
          const salespersonId = order.salesperson_id || null

          // Upsert customer by email
          const { data: existingCustomer } = await supabase
            .from('customers')
            .select('id, customer_status')
            .eq('email', orderEmail)
            .single()

          let customerId: string

          if (existingCustomer) {
            // Update existing customer
            const newStatus =
              existingCustomer.customer_status === 'customer' ? 'repeat' :
              existingCustomer.customer_status === 'repeat' ? 'repeat' :
              'customer'

            await supabase
              .from('customers')
              .update({
                customer_status: newStatus,
                assigned_salesperson_id: salespersonId,
                lead_id: lead.id,
                first_name: lead.first_name || undefined,
                last_name: lead.last_name || undefined,
                phone: lead.phone || undefined,
                last_order_at: new Date().toISOString(),
              })
              .eq('id', existingCustomer.id)

            customerId = existingCustomer.id
          } else {
            // Create new customer
            const { data: newCustomer } = await supabase
              .from('customers')
              .insert({
                email: orderEmail,
                first_name: lead.first_name || null,
                last_name: lead.last_name || null,
                phone: lead.phone || null,
                customer_status: 'customer',
                assigned_salesperson_id: salespersonId,
                lead_id: lead.id,
                first_order_at: new Date().toISOString(),
                last_order_at: new Date().toISOString(),
                total_orders: 1,
                total_spent: order.total || 0,
                acquisition_source: 'admin_sales',
              })
              .select('id')
              .single()

            customerId = newCustomer?.id || ''
          }

          // Backfill customer_id on project, cart, and order
          if (customerId) {
            await Promise.all([
              supabase.from('projects').update({ customer_id: customerId }).eq('id', cart.project_id),
              supabase.from('carts').update({ customer_id: customerId }).eq('id', cart.id),
              supabase.from('orders').update({ customer_id: customerId }).eq('id', order.id),
            ])
          }

          // Mark lead as converted
          await supabase
            .from('leads')
            .update({ status: 'converted' })
            .eq('id', lead.id)
        }
      } catch (conversionErr) {
        // Conversion is non-blocking — order was already created successfully
        console.error('Lead→Customer conversion error (non-blocking):', conversionErr)
      }
    }

    return NextResponse.json({
      success: true,
      order,
      order_number: order.order_number,
    })
  } catch (error) {
    console.error('Order POST error:', error)
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}

/**
 * GET /api/admin/orders
 * List orders with filters and pagination.
 * Supports ?source=legacy to query legacy_orders table.
 */
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const source = searchParams.get('source') || 'orders'
    const status = searchParams.get('status')
    const salesperson = searchParams.get('salesperson')
    const search = searchParams.get('search')
    const page = parseInt(searchParams.get('page') || '1')
    const limit = parseInt(searchParams.get('limit') || '25')
    const offset = (page - 1) * limit

    const supabase = createAdminClient()

    // ---- Legacy orders ----
    if (source === 'legacy') {
      let query = supabase
        .from('legacy_orders')
        .select('*', { count: 'exact' })
        .order('order_date', { ascending: false })
        .range(offset, offset + limit - 1)

      if (status) query = query.eq('status', status)
      if (salesperson) query = query.eq('salesperson_username', salesperson)
      if (search) {
        query = query.or(
          `order_number.ilike.%${search}%,email.ilike.%${search}%,billing_first_name.ilike.%${search}%,billing_last_name.ilike.%${search}%`
        )
      }

      const { data, error, count } = await query

      if (error) {
        console.error('Error fetching legacy orders:', error)
        return NextResponse.json(
          { error: 'Failed to fetch legacy orders' },
          { status: 500 }
        )
      }

      // Normalize legacy_orders columns to match the standard Order shape
      const normalized = (data || []).map((o: Record<string, unknown>) => ({
        id: o.id,
        order_number: o.order_number,
        email: o.email,
        billing_first_name: o.billing_first_name,
        billing_last_name: o.billing_last_name,
        status: o.status,
        total: o.total,
        salesperson_name: o.salesperson_username || null,
        created_at: o.order_date,
        payment_status: o.transaction_id ? 'paid' : 'unknown',
        source: 'legacy',
      }))

      return NextResponse.json({
        orders: normalized,
        total: count || 0,
        page,
        limit,
        totalPages: Math.ceil((count || 0) / limit),
        source: 'legacy',
      })
    }

    // ---- Standard orders ----
    let query = supabase
      .from('orders')
      .select('*, staff!salesperson_id(id, name)', { count: 'exact' })
      .order('created_at', { ascending: false })
      .range(offset, offset + limit - 1)

    if (status) query = query.eq('status', status)
    if (salesperson) query = query.eq('salesperson_id', salesperson)
    if (search) {
      query = query.or(
        `order_number.ilike.%${search}%,email.ilike.%${search}%,billing_first_name.ilike.%${search}%,billing_last_name.ilike.%${search}%`
      )
    }

    const { data, error, count } = await query

    if (error) {
      console.error('Error fetching orders:', error)
      return NextResponse.json(
        { error: 'Failed to fetch orders' },
        { status: 500 }
      )
    }

    // Flatten joined staff name into salesperson_name for frontend compat
    const orders = (data || []).map((o: Record<string, unknown>) => {
      const staff = o.staff as { id: string; name: string } | null
      return {
        ...o,
        salesperson_name: staff?.name || null,
        staff: undefined, // remove nested object
      }
    })

    return NextResponse.json({
      orders,
      total: count || 0,
      page,
      limit,
      totalPages: Math.ceil((count || 0) / limit),
      source: 'orders',
    })
  } catch (error) {
    console.error('Orders GET error:', error)
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}
